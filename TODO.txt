


----------
stack test --test-arguments='--match "Parliament"' --file-watch
[![CircleCI](https://circleci.com/gh/pdlla/potato-flow.svg?style=svg)](https://circleci.com/gh/pdlla/potato-flow)

normal
√∏√ó√ò‚Åê‚Ç™
‚Ü∫‚Üª

WIDE
üò±
‚ß¨‚ß≠
‚®Ä
‚®Ç
üîìüîí
üîèüîê
üìÅ
üìÇ
üëÅÔ∏è
üôà

::NEWEST TODO::

-finish SetPotatoDefaultParams...
  DONE-use these settings when creating new elts inside of Handler
  DONE-read these settings in Params when nothing is selected
  DONE-set these settings in Params when nothing is selected
  DONE-set _setPotatoDefaultParameters_sBoxType correctly in Params
  DONE-you broke TextAlignment params update somehow (clicking to change text alignment does not update the choice)
  DONE-linestyle default setting does not work
-clicking from params to canvas causes changes to reset :(
-locked/hidden stuff
  DONE-BUG, right now if you select via folders, do and operation, unselect, it will allow you to reselect locked/hidden stuff for some reason üò±
    -this must be happening because something is being set incorrectly inside of layerMetaMap??
  DONE-because folders allows selecting locked/hidden stuff, you need to remove this stuff before generating handler from selection
    DONE-you also need to remove locked/hidden stuff into selection that gets passed into handlers
  DONE-pipe through ControllerMeta into GoatWidgetConfig such that you can instantiate tests with various lock/hidden/collapse states
  DONE-omit locked stuff from selection set somehow
    DONE-inside of handler and drag+select case in GoatWidget
      -no seleciton of locked or hidden stuff
      -modify selectMagic
    DONE-direct selection via layers
      -OK to allow for selecting locked items for dragging purposes but not for manipulation? (This goes for hidden as well)
    DONE-UTs for selection handler and drag+select
    DONE-UTs for selection via layers
  -you might want to consider disallowing selection of locked stuff (directly NOT ok, via parents OK)
  -omit hidden layers in render function
    -(don't forget to do it for selection rendering too or does it not matter becaues you shouldn't be able to select hidden stuff??)
-test for leaks again
-figure out if paste is done via repeated inputs or actually via paste event
-make sure it's not possible to open up a pop up whilee mouse dragging (or you will break mouse drag pane2 stuff again)
DONE-UT ControllerMeta loading
  -ugh
-BUG hitting assert
  selectionToSuperOwl (CanvasSelection selection) = assert (Seq.length selection == 1) $ Seq.index selection 0
  repro (select a bunch of stuff and try and shift click a bunch on linux???)
  DONE-dump state/tree
-multi node lines
  -research how lucidchart does it? (they use edge draggers instead of corners (avoids doubling back issue) but this won't look good in vty)
  -you really need to design+determine all line types first
  -cartline needs a SElt type
  -decide how to combine Line and CartLine
    -click + drag produces reuglar line
    -click release in same spot takes you to CartLine
  -may as well do attachments while you're at it
    -same as regular line except last points auto track to their attaching points, may create some un-editable joints
    -how to detach?
    -how to attach during creation?
      -click on attachment point... attaches
      -ctrl click does not attach
-folder stuff
  DONE-BUG you can stil drag folder into itself which causes crash wtf I thought I fixed this
  -add invalid folder drag test
  -when you select a folder and it auto selects children, you can't click and drag the children
-create new folder stuff
  -auto expand folder after dragging into it
  -after renaming folder, clicking on canvas pane does not finalize the folder rename action until you click back on the layers pane
    -you need some kind of click off pane reset type action to handler
      -can you tie this into graceful handling of bad mouse states?
  DONE-do proper folder position
  -consider making new elts get created inside selected folder rather than above it?
  -empty folders should not be expandable? (set to expanded by default)
  -add UTs
-figure out why scrolling in file explorer is hecka broken
  -I don't think there's anything wrong with code, scrolling freezes input for some reason in vty on mac terminal :|
-delete layer scrolling support from GoatWidget. I can't remember why I did this anymore
-BUG foldgoatfn gets called 3 times for each event wtf üò≠ (probably due to holdUniqDyns I guess)
  -you should fix cuz it makes debugging hard...
  -you got it down to 2 :O
-disable selection highlight in some modes
-pull settings from home directory
  -what does this do on windows?
-file explorer
  -getting filename and last folder confused
  -apply styling
  -initialize app with correct folder
  -prompt to save if not saved
    -would be nice if we had potatooutput state thingy
  -display filename somewhere with * if not saved
    -on start, it should pop stack, on exit it should pop stack
  -ctrl-o to open
  -ctrl-n for new file
  -add quit button somewhere?
  DONE-typeable file path bar
  DONE-double focus between filename and folder
  DONE-fix h scrolling in filename input
  DONE-ctrl-s to save
-figure out how to change folders into groups for auto-pathing group support
  -is it just a folder setting?

DONE-BUG radiolist width counting function is wrong (I think you forgot spaces between boxes)
DONE-MINOR box title allows news lines (they just get hidden, forbid new lines in box title entry method)
DONE-folder renaming doesn't allow spaces
DONE-BUG paste does not work for folders
  -WSEAddRelative needs to use OwlMiniTree
DONE-add line ending params
DONE-connect height correctly in params?
DONE-fix SBoxType params
DONE-[graceful handling of bad mouse states] probably add hack to ignore inputs that didn't come from the same source until it's corrected (or force a cancel)
DONE-I think you broke folder depth dots (remember it's only for when you drag)
DONE-BUG owlTree_addMiniOwlTree order is incorrect for top level elts
DONE-BUG if elt is drag onto its own spot in list, it crashes
  IGNORE-you can probably fix this by preventing dragging back onto same elt (i.e. no move)
    -this breaks multi-move though...
  DONE-add UT for this
DONE-widgetify left panel
DONE-fix dynamic heights in left panel
DONE-pass out dynamic height in params
DONE-BUG pane2 has broken save/savas and generally stuff that opens up a popup due to popup overriding mouse capture
  -fix by activating on mouse up instead of down...
DONE-text area
DONE-ui work
  DONE-rework tools menu to be more readable
    DONE-add tools for text area and maybe multiline
  -resize left pane to be correct
  -add little indicator indicating you can click to enable box labels?
  DONE-add hotkeys to MOTD?
DONE-hotkeys for choosing tools are broken (every other hotkey is broken...)
DONE-textarea click to select enters textarea handler
  DONE-still broken after dragging??? whyy
  DONE-also cursor is not getting psased in correctly (need to handle on mouse up)
DONE-BUG selecting folders does not create select boxes
  -need to use converted selection in select handler?
    -or do I want to make converted selection available via PotatoHandlerInput
DONE-must click to focus on canvas (after having focused on layers) for input to registerv
FAIL/IGNORE-add State to PotatoReader
DONE-highlight parents with selected children gray (repuprose INHERISTSELECET)
DONE-layers rename handler renderer
DONE-must click to focus on canvas (after having focused on layers) for input to register
DONE-click on layer  and drag to canvas area causes freeze
  -generally speaking clicking and dragging to other panes is kind of broken
DONE-BUG selecting folders does not create select boxes
  -need to use converted selection in select handler?
    -or do I want to make converted selection available via PotatoHandlerInput
DONE-box handler drag/move should probably check if you actually clicked on a elt before letting you drag
  -right now you will drag if you click on nothing if it's inside the box
DONE-box labels


-EXTRA BONUS TODO
  -break up foldgoatfn to clean up stuff, in particular, so you can have dedicated file load / initialization code path
  -attachments
  -text box should indicate overflow when in text entry bode
  DONE-box labels
  -glyph widget
  -consider refactoring layers handler
  -consider refactoring handlers to output commands so you can make everything even more scriptable
  -would be nice to select line anchors and then have keyboard input on the selected anchor
  -"convert to text area" option
  -right cilck menus
  -serialize action stack
  -actual MDI
    -ctrl-t for new tab
    -ctrl-w for close tabe
    -ctrl-{/} for tab left/right
  -(requires [TextZipper selection]) click to rename folders should really select all existing text
-BONUS TODO (TBH you need to do this to make the product useable)
  -do proper theming dark/light
    -theming/design pass
  -keyboard input
    DONE-box handler
    -for line handler it should operate on the last anchor selected
  -layer show/hide
    -test impl
    -refine UI
    -probably easiest to do inside of updateCanvas
  -save, save as, open, print dialogs
    -you want a settings widget to track which is current directory/file
  -live selection preview
  -handlerrenderoutput should be bale to do grey background for text boxes and stuff
  -multi-line handler
  DONE-freeform
  -toggle box to textbox to freeform
    -this operation can not be reversed popup :O
  -user settings object in vty
  -MDI refactor
  -box label text alignment parameters
  DONE-selection box
  DONE-separate selection rendering
DONE-still getting same source assert when dragging to/from layers/canvas
  DONE-(write Ut for this)
  DONE-I think you just need to switch layout stuff to use pane2
DONE-add sorting to BroadPhase somehow...
  -fix select order
  -ok you didn't actually fix render order...
DONE/IGNORE-color config object
  -entry box valid
  -entry box entering
  -entry box grayed
  -background
  -text
  -etc

-make a set of Goat verifiers for testing in vty UTs
-glpyh selector-search widget
  -at least basic version which has a tab listing standard ASCII stuff
  -and then tab for all the best emojis :O
  -prob take symbol list + lookup table for searching
  -save recently used on exit
-BoxText
  DONE-add alignment to text zipper
  -add BoxTitle
    -maybe left/right/center text
    -add padding to BoxText
  -text box type should highlight not cover
  -text box should indicate overflow when in text entry mode
-DisplayLineConfig
  -Wrap Words
  -Wrap Characters
  -Overflow
  -Clip
-do multiline stuff :D
-switch to endo style folding in goatwidget so you don't need to use ignoreMouseUnlessFocused
-hook up unicode width fn
  -add hook for it in renderer
    -erhh, this may need some refactoring...
  -maybe need it in broadphase too? Prob not
-add screen size support to GoatWidget (for rendering OOB)
-menu bar?
  -open/save/load/quit/about
    -maybe don't worry about submenus for now üò±
  -you need to use zipper if you want sub menus
-new vty window stuff
  -MVP is some floating windows that modify something in base window
-consider adding second cursor type, "v" and "a" equivalent (probably ignore)
-handlers should render as background fill color
  -and to be even more awesome, you could render on top for when moving things is background I guess
-more efficient replacement for doesSelectionContainREltId
-need narrow phase selection methods, i.e. can't just do it using boxes
  -make sure to test :)
-make flowchart diagram of handler setting rules
  -non-canvas event (does this reset?)
  -external event (calls new reset function)
  -capture + active + changes
  -(capture/no capture) + not active + changes
  -no capture (must not be active)
  -returns Nothing handler
-tests
  -undo/redo test
  -more params tests
  -undo redo of text
    -you should really set up a 1000 undo redo sorta thing again
-rendering
  DONE-get rid of BroadPhaseState (carry changes around separately)
  DONE???-layer show/hide needs to return SEltLabelChanges
  -render based on screen not canvas
    -add _goatWidgetConfig_screen Dynamic t (Int,Int)
  -wrap initial render into helper function
  DONE/IGNORE-finish TODOs in updateCanvas
  DONE-rendering happens in GoatWidget??
    -or just make sure utility functions make it easy enough to do this outside of GoatWidget
-user defined SuperStyle presets
-if you are in BoxTextHandler mode and you have Text tool selected
  -then you click and release outside box, you will go back to boxtext handler
  -so I guess click release with any creation tool should deselect everything
  -or not, maybe this is ok...
-PFStateChangeFlag and have each PFState operation return a change flag as well
-SimpleSEltLine
  DONE-renderer
  -prototoype connections
-refactor for ordering service spec D:
-SPECS
  -params spec
  DONE-vty attr spec
  DONE-cartesian lines spec
  -group spec
    -group is prob just a folder that auto selects everything in said folder, you can subgroup but it just adds to the parent group effectively
    -you can select individuals group elts via layers
    -eventually implement focus mode
  -improved renderer spec
    -kd tree in broadphase I guess
  -connections spec
    -there may be missing/invalid connections, that's ok, just figure out a way to handle them
      -note, you must still be able to manipulate things with invalid connections so this could get messy
      -this way if you undo, the connection gets restored
  -insert mode text area spec
    -(how to handle resize??)
  -line intersection renderer
    -connects to lines, renders their line intersections
  -unicode spec
    -wide chars and graphene clusters
-layer bonus
  -write method to update layers incrementally when there are changes + when moving elements around in layers
    -write now you just inefficientlly call generateLayers every time...
  -layer drag select

DONE-TINY TODO
  DONE-layers
    DONE-scrollbar/border to layers panel
      -change rendering based on scroll position
      -needs box indicating scroll position (v scroll bar I guess)
      -why does scrolling get managed by GoatWidget again?
    DONE-add rename support to layers
      -clicking away from layers panel (onto canvas or some other params) should cancel all layers interaction
    DONE-fix layer keyboard input capturing
    DONE-remove inherit selection highlight
    DONE-implement highlight drag drop (see nested layers below)
  DONE-add character to handlers and show highlighted text
  DONE-fix multi-select resize
  DONE-params crap
    DONE-fix focus in params ugh
    DONE-fix cursor highlight in params
  DONE-reverse render order
  DONE-add dividers in LHS to indicate where each UI region starts/ends
    -to be more awesome you could color each section differently...
  DONE-off canvas rendering??
    DONE-you need to change dynamic XY to event XY (and set initial state with an event) to avoid cyclic eval...
  DONE/IGNORE-block inverted squares (how to handle multi-select?)
    DONE-you broke it, fix pls
    DONE-write a UT for this
    DONE-this is hard because of "undo first" issue makes it difficult to recover state we are operating from
      -we can either invert the operation locally
      DONE-or we can modify the operation in PFWorkspace before popping onto action stack
  DONE/IGNORE-prep for testing
    DONE-get rid of PFWidgetCtx and use specific instances
    DONE-write harness for testing Params, Tools, etc...
DONE-7/2021 folder drag bugs
  DONE-can't reach last spot
  DONE-clamping seems to be wrong (need to +1)
  DONE-sibling computation puts you in wrong spot for some reason
  DONE-isundofriendly assert should only lump together stuff that has the same parent I think
  DONE-must deny selecting child of a selected object
    DONE-visually do shadow select to indicate this in layers so it's no confusing?
  DONE-add dots for dragging several layers so it's clear which folder you're going under
  DONE-do selection correction in GoatWidget rather than deny invalid selections
    -this is really sucky b/c if you have folder selected in layers then you can't select any of its children in main area
    -prob best way to fix is selecting parent includes all children in selection (locked and hidden stuff removed in main are aselection when we implement it)
      -when deselecting child, then this must deselect all selected parents recursively... hmm
  DONE-fix shift select parent case (must deselect selected children)
    -alternatively, you could do disjoint uninon with selected children.. whatever
  DONE-due to layers capturing input now, ctrl-z doesn't work after doing layer drag
    -delete key after selectinglayers sorta dosen't work either
  IGNORE-possible to make bad selections sometimes
  DONE-invert text box crashes still
  DONE-layers
    -no selection darkening
IGNORE-setup GHCI with hoogle :O http://dev.stephendiehl.com/hask/#ghci
DONE-BUG add sorting to selectMagic
DONE-BUG deleting folders does not delete children from canvas
  -Ok, now when you undo a delete folder it breaks :(
DONE-fix kb capture issue with layers
DONE-something is resetting _layersRenameHandler_zipper making renaming not work...
DONE-params MVP
  -toggle box border?
  -line style??
  -make a UT for setting params
IGNORE-layers test for the future
  -rename (when supported)
  -drag move collapsed folder
  -select non-contiguous elements and drag+move
DONE/IGNORE-rename Entry/newmemtest/Testing/Directory to DEPRECATED
IGNORE-layers
  DONE-consider doing tree structure for folders
  -layers (probably go with "more complicated select")
    -layers selection and actual selection are different
      -need a way to figure out parent
        -refactor layers to use tree structure
        -maintain an IntMap LayerEntry for non-visible LayerEntry as well
        -maintain IntMap REltId parent map
    -render selection in layers (add selected state to lentry)
    -PFEMove moves all children if folder was moved
      -addAllChildrenToSelection
    IGNORE-select folder start also selects folder end in layers
    -shift deselect test
    -add deselect support to LayersHandler ???
  -selectMagic should ignore locked elements
    -test it
  DONE-finish changesFromToggleHide
    -test it
DONE-nested layers
  DONE-dummy square at bottom
  DONE-highlight square indicating where you will drop to
    -need to offset LayerEntries to accomodate
  IGNORE-if mouse comes from above, highlight square enters into folder
  DONE-render handlers for layers
DONE??-do proper prevent inverted box in PFWorkspace
DONE-text zipper
  DONE-fix cursor pos on right alignment D: (easy way to fix is just to offset right by 1)
    -test
  IGNORE/DONE-text alignment UTs
  DONEüò≠-test with wide chars (in vty)
  DONE-put up PR :O

DONE-Owl TODO
  DONE-write validate function
  DONE-name functions in Owl to be consistent
  DONE-finish UTs for workspace
DONE-switch to use git submodules ffs
DONE/FAIL-setup linux :O???
IGNORE-delete manual install of haskell language server and use ghcup
IGNORE-consider moving layer position into REltIdMap directory
  -to do this efficiently you should track which elements actually had their position changed
  -or consider converting layers into a tree first blarg you need to do this sooner or later
    -except it's not clear how to sort elts if they are in a tree oh no
IGNORE/DONE??-queueVtyEventAndFire
IGNORE-create a PR for readDynamic
IGNORE/DONE-proposal for adding modifiable context object to VtyWidgetCtx
  -also takes config function to modify inside of pane or something

DONE-do keybord capture for params
  -relayout widgets so it's easy to pass returned values around or whatever
  IGNORE-maybe make your own Reader/DynWriter monad pls
DONE-update render area based on canvas size
DONE-a few more presets
IGNORE-redo cellInput pls
DONE-also create numInput
DONE-canvas size param (shows when nothing is selected)
  -pass event out of params widget
DONE-clicking onto canvas from params will trigger 2x goat events (1 to modify params due to focus change, and 1 canvas event)
  IGNORE-could resolve using Endo üò±(or just apply foldgoatfn several times..)
  DONE-ignoreMouseUnlessFocused
DONE-add reader to stack :O

DONE-figur out why I wrote the comment -- if shift is held down, ignore inputs
DONE-layout
  -make interface create layout with different tab events
  -cleanup exported stuff in layout
  DONE-consider making number of kids dynamic
  DONE-tests for vty layout
    -helper for reading Dynamics in test monad
DONE-params MVP old
  DONE-do layout improvement in vty D:
  DONE-scan params and look for same stuff
    -don't need to do anything with this yet, just put the methods in there
  DONE-add Dynamic Int output to params widget
  DONE-add Maybe to params widget so they don't get displayed if no such option exists
  DONE-fix tab widget recreation issue preventing you for tabbing accross style widget
    DONE-also need to reset cursor to start
  DONE-figure out how to do invis fill?
    -erase and hit escape or return üëçüèΩ
    -maybe just add an invis fill button
    -fill should be separate from rest of stuff in preset params

DONE/IGNORE-rethink keyboard input capture
  -params needs to capture keyboard input
  -params need to receiev events from glpyh selector
DONE/IGNORE-you probably want to build in input hierarchy
  -popup > menu > params etc > rest
  -make widget wrappers
  -ignore input when simulataneous with another event
  -some focus widgets??
  -find a place to put all these
DONE-render cursor position in text area (get cursor pos from displayLines)
DONE/IGNORE-single line text area
  -max width?
  -reset to start
  -colors
IGNORE-try vscode again :O https://github.com/haskell/haskell-language-server
DONE-try stacktrace omg
  $ ghc -O0 -rtsopts=all -prof -auto-all --make stacktrace.hs
  ./stacktrace +RTS -xc
DONE-add output to main to figure out how many ticks fire per event (and what frame # it's at)
DONE-do alignment offset in boxtext
DONE-click to focus on text handler should also pass in input so you can focus TZ cursor at spot where you clicked
  DONE-add a test for this
DONE-fix handles being rendered too late IDK how D:
IGNORE-why does loading file select stuff?
DONE-first character of left align text box is incorrect (seems to be space character instead of Nothing)
DONE-why does large canvas slow down stuff so much. Rendering shouldn't be that bad???
  -doesn't seem to be taking advantage of laziness either
  -seems to just be a profiling mode thing...
DONE-new vty layout stuff
  DONE-get rid of post build dependency
  DONE-(tile . fixed)/(tile . stretch) take regular VtyWidget
  DONE-make typedef for (,,,) thing
  DONE-document
  IGNORE-probably get rid of IsLayoutResult class
  DONE-finish LayoutDebugTree (rename)
DONE-change SuperStyle to Maybe PChar :scream:
DONE/IGNORE-decide what to do about layouts (mouse needs pane2)
  -think about doing docking windows or whatever
DONE-no border box support
  -I guess you can make border and text two separate toggles?
DONE-do popup fancy :O
DONE-finish params widget
  DONE-create set of Params modifying widget, something that ultimately does
    Dynamic t SuperOwlParliament -> m (Event t WSEvent)
  DONE-create something like
    layoutDump :: DMap ParamTypeTag (MinDimensions, VtyWidget t ???) -> VtyWidget (DMap ParamTypeTag ???)
  DONE-although tbh, you can just replace DMap with [] since every params widget returns the same type prob?
DONE/IGNORE-TextArea stuff
  -handle updating text zipper when the stext lbox gets updated
  -figure out how to handle funny case where space and newline characters get hidden if they happen right at the end of a wrap
    -you'll need to store a second piece of data alongside TZ to track this (i.e. raw string)
  -clear out pSelectionChanged comments
IGNORE-params
  DONE-prob a view only thing, add hookup for params in goat widget I guess
  -need common methods for reading style of multi-select stuff
  -is there a way to systemize different types of styles
    -SuperStyle
    -TextStyle
    IGNORE-LineStyle
      -make this part of SuperStyle
      -when displaying, show simplified version of it
    -BoxTitle
IGNORE-although maybe you'd be better off just disallowing these from being created (in creation/modify, just ignore if result is 0 size box)
DONE-mouse select should select 0 size elts
DONE-copy pasta translate a little by default?
  -or attempt to place in middle of canvas viewport prob better
DONE-get rid of broadphase state
DONE-generate vty char width table
DONE-see if unicode combining marks work after you generate the table
DONE-write a UT for negative area box text as this is causing a negative index issue somewhere with the text zipper probably
  -you prob want to short circuit if box is negative and just display nothing or whatever and stop updating TZ
DONE/IGNORE-go over box sizing semantics
  -it seems you may be off by one, (i.e. a 2x2 size box renders as a dot D:)
DONE-figure out why sbox doesn't render right in vty
DONE-toMouseManipulators broken
DONE-SEltLine drawer broken when arrow goes in wrong way (indexing into arrow heads wrong)
DONE-if you get an event while BoxText handler is open, it will break undoFirst stuff
  -you need to track when non-handler events come in...
    -you'll have to do this anyways for multi-user mode right?
    -maybe just remake the handler, or perhaps add a reset method to handler??
      -should reset method take SEltLabelChanges... it probably should D:
IGNORE-assert handler is inactive if it does not capture
DONE-box border offset/no offset stuff D:
DONE-box text renderer lol
DONE-box with border test D:
  -pretty sure there is a bug with this in BoxText
IGNORE-default don't fill boxes pls
DONE-right now if you click realease on a text box it will go straight into BoxText handler, only do this if it was already selected
DONE-get basic box working using existing text zipper
  DONE-add UTs (assume align left for now so they'll work when you add alignment)
DONE-add text functionality to SEltBox
DONE/IGNORE-custom serializers for SEltLabel
  DONE-prob just use Data.Binary
  IGNORE-thought you could do something more efficient to omit optional parameters
  IGNORE-save load test
DONE-connect handlers to vty
DONE-connect layers to vty
DONE-sort out input hierarchies in vty
  DONE-support popups
  DONE-layers/canvas separate mouse input
  DONE-keyboard goes to popups/params first, then to goat
  IGNORE-am I missing anything??
DONE-consider making REltId serialized (you'll need this to do connections)
  -remember to support copy pasta of connected elts
DONE/IGNORE-think through what additional data is needed to validate for undo/redo in multi user mode
DONE-rename master branch
DONE-resolve ControllerMeta REltId synchronization issue
DONE-copy pasta
  DONE-implement copy
  DONE-ctrl-v/s/z/etc sent via keyboard,
    -other kind of copy paste supported via KeyboardKey_Paste
    -we'll prob need to do something different for web version...
  DONE-copy pasta test
  IGNORE-I think the way it's handled right now (PFEventTag operations) is correct, because then you can intercept copy pasta events to do copy pasta during text selection etc.
DONE-remove scroll position from layersState
DONE-test for ignore keyboard inputs during mouse drag
DONE-layers
  DONE-figure out how to handle layer inputs...
  DONE-connect layers
  DONE-layer handler test
    DONE-select
    DONE-shift select
    DONE-hide/lock folder
    DONE-drag move folder
    DONE-collaps folder
DONE/IGNORE-select folder (I guess auto selects all children?)
  -c.f. what illustrator does
  -what happens if child is locked? (c.f. if illustrator lets you move parent with locked child)
DONE-consider using a single MouseDragState_Cancelled to communicate cancelled instead of escape key
  -this allows us to add an invariant at the handler level where no keyboard input happens until mouse was released
DONE-move layer state to backend and connect to changes
DONE-figure out how to get most current version of PFState
IGNORE-figure out why some of the tests pass even though you used out of date PFState
IGNORE-broadphase stuff in backend needs latest layerPosMap and PFState ug
DONE-combine everything and entry üò±üò±üò±üò±üò±üò±üò±
  -maybe do this at the end, won't get that much harder prob...
DONE-remove pHandleCancel
DONE-connect TextArea handler
  -potato text area input
  -text area tool should create a box and after box is finished it should go straight to edit mode in text area handler
IGNORE-connect RenderedCanvasRegion
IGNORE-think of some way to make _pFState_directory type safe
  -partial from accessing by REltId index
  -partial from trying to operate on possibly incorrect type
  -you can make it not partial if you get a selection to operate on and in the set operation it's always override (no modify)
DONE/IGNORE-layers
  DONE-add selection to layerInputNew
  IGNORE-add tests for layerInputNew
  IGNORE-drag select
  DONE-decide where to store layer state
  DONE-layer drag interface (mouse position or more abstract?)
DONE-implement override handler as per spec above (ANOTHER OPTION)
DONE-incremental render function
  -moveRenderedCanvasRegion :: LBox -> BroadPhaseState -> PFState -> RenderedCanvasRegion -> RenderedCanvasRegion
    -first do moveRenderedCanvasRegionNoReRender :: LBox -> RenderedCanvasRegion -> RenderedCanvasRegion
    -then call renderCanvas and rerender newly moved areas
  -updateCanvas :: SEltLableChanges -> BroadPhaseState -> PFState -> RenderedCanvasRegion -> RenderedCanvasRegion
DONE-rename LBox methods to lBox
IGNORE/DONE-figure out how you want to handle layer input using handlers
  -seems like there's a handler stack....
    -layers > override > normal > no capture select/select+drag
IGNORE/DONE-consider doing override handlers for
  -this is needed so that when you cancel, you get back the original handler and state
  -also creates good separation of normal handler cases and so called "override" cases
  -cases:
    -new element handler case
    -pan handler case
    -select and drag + select case
IGNORE-broadphase tests
IGNORE-incremental rendered canvas test
  -i.e. add delete etc...
    -better to extract renderedCanvas calls in EverythingWidget into its own module for easier testing
DONE-potatoHandlerOutput needs to handle layer hide/lock stuff
DONE-make sure rendered canvas deletes deleted elements
DONE-cleanup
  DONE-make Layer/Layers consistent
  -clear warnings
DONE-load test
DONE-connect _pfo_potato_changed to load inside of workspace
DONE-test that loading actually triggered _pfo_potato_changed
DONE-test vty with non trivial initial state
  DONE-maybe expose some test helpers for vty
DONE-expose initial state
  -canvas (pull from initial pfstate)
  -pfstate
DONE/IGNORE-finish text area handler
  DONE-kind of want to combine BoxHandler functionality D:
    -if we don't allow box manipulation in text edit mode then we can have Boxhandler return a TextHandler :O
DONE/IGNORE-text manipulators
  DONE-idk D: make your own zip, how bad could it be
  DONE-decide how to handle wrap/overflow
  DONE/IGNORE-selecting text defines the text mainpulator that covers the whole place
    -if not selected
      -click drag selects and drags
      -click selects
    -if selected
      -click enters edit mode at cursor position
      -if edit mode
        -click drag does selects text
      -if not edit mode
        -click drag drags
DONE-new controller type sketch
  -controllers are universal
    -change style
    -change size (erhm, make sure your mindful about handling undo operations across diff types?)
    -per-SElt controllers
  -if controller is applied to incompatible type, assert for now
IGNORE-click + drag needs to CTagBoundingBox and not CTagBox or it will only work on SBox
  IGNORE-maybe easier just to make BoundingBoxHandler
    DONE-ignore this, see new controller sketch
IGNORE-make controller module for easier imports...
DONE-finish simple line handler
DONE-test simple line handler
IGNORE-add test to ensure REltId does not change from undofirst
DONE-mousehandler :O
DONE-update tests so they check for new handler states
DONE-you forgot to add pan functionality D:
DONE-figure out how to call makeHandlerFromSelection after making a new selection
  DONE-pass on new handler from backend after selection is made
  DONE-regular select cases, (layer, select tool)
    -ok for handler to override previous one
  DONE-select + drag box handler case
    -select on click, creates box handler, drag can take over next frame?
  DONE-select from new elt case
    -fack TODO figure this out
    -right now handler from backend will overwrite the creation handler D:
    DONE-2 solutions
      DONE-pIsHandlerActive solution
        -this isn't terrible has handlers seem to have 2 distinct modes... at least you sort of made it that way by having combining drag manipulators with selection modals
      -split up new elts from tools and other cases (copy pasta, undo/redo) and don't do new handler in new elts from tool case
  -other select cases
    -there are currently no other select cases
    -can we treat select output in PFO specially then?
      -like 'Either SomePotatoHandler SuperOwlParliament' since they seem to be exclusive
DONE-create handler from selection helper
DONE-finish select handler
DONE-box handler needs to handle creation case
DONE?-bbox handler (could just use box handler, but it's a little sloppy this way...)
DONE-ensure handler stuff works with no regression in tests
DONE-HANDLER PLAN
  DONE-return type needs to be changed to Maybe PotatoHandlerOutput where Nothing means input was not captured at all
  DONE-need to pass in broad phase for selecting
    NO-or perhaps select returns a box to be selected?
  DONE-need to add render function
  -new selection generates new handler and cancels previous one, this handler must be stored in backend
DONE-add modifiers to keyboard
DONE-decide how to handle cancel in mouse drag handlers
  -either pass in cancel mouse state or pass in escape key
  -make sure that future cancel mouse drag stuff is correctly ignored
    -I think it's best if cancel mouse states aren't passed in so that handlers don't need to individually account for this
      -except this means it is expected for escape key to cancel the handler
        -so you should add a separate method for cancelling handler so that this assupmtion is clear

DONE-undo permament instead of undofirst
  -you need this if you want to support tracking layer states through undo/redo
  -also just a good idea in general I think...
IGNORE-prob switch to text-zipper
DONE-decide how to handle optional fields in controllers
IGNORE-figure out how to add sub modals (e.g. text edit mode) to frontend
  -you could actually probably get away with reusing lastOperation but that's probably asking for trouble
    -so just create a new frontend state var for modals?
    -maybe you can a special clear method that doesn't reset modal state vars when relevant?
      -clearLastOperation :: FrontEndOperation -> FrontEndOperation
      -this is simpler because modal state vars are onyl present when modal is active
        -in this case lastoperation becomes a standin for modals
    -if yo udo this you should change MainpulationIndex into some more fancy Manipulation state object
DONE-layer tests
DONE-text area tests
DONE-look into doing pending selection for immediate select + manipulate
  DONE-add test for single click select + actually manipulate
DONE-proper cancelling (maybe add new state var to ignore mouse stuff?)
  DONE-fix cancel tests so that they try and do stuff after the cancel
DONE-manipulate tests
  DONE-test cancel in creation case
  DONE-test cancel in manipulate case
DONE-correct manipulator so it takes selection directly in front end
  -manipulate :: MosueDrag -> (SelectionManipulatorType, MouseManipulatorSet, ManipulatorIndex) -> (ManipulatorIndex, Maybe Controller)
DONE-create separate file for manipulator test
  -maybe improve testing framework a little to have more helpers for testing elts (and giving them names)
DONE-switch to makeManipulationController
DONE-sepearet mouse stuff out of Everything
DONE-seperate Manipulator out of Everything
DONE-remove reflex folder, Entry goes into Flow folder
DONE-figure out manipulator drag through another manipulator issue
  -also we want a general interface for all types of manipulators
DONE-add modifiers to LMouseData
DONE-undo first does not reset RID counter for some reason
DONE-selection tests
  DONE-basic
  DONE-test cancel
  DONE-test add/noadd to select
  DONE-test single click select
DONE-fix memory leak again ;__;
DONE-need to use doCmdPFTTotalStateUndoFirst inside Entry
  -only need for addElt, manipulateElt and maybe resizeCanvas
DONE/IGNORE-redo manipulator storage in everything
  -list of manipulators
  -you need a better way to track which is the active manipulator
    -instead of iterating trhough thelist... though maybe that's not the worst
  -here is how it should work:
    -selection -> indexed list of manipulators + drag delta function
DONE-hook up PF
  DONE-pass in initial state into EverythingFrontend
  -prob output PF in EverythingBackend
DONE-manipulatingDyn can be moved into backend

:: 3/2020 Menu Spec

>File
  >New (closes current doc for now, eventually opens new tab)
  >Open
  >Save
  >Save As
  -------
  >Theme D:
  --------
  >Quit
>Tabs
  >next tab
  >prev tab
  >close all
  >close current
  >close all but current
  ><list all tabs>
>Windows
  >default preset
  ><presets>
  >edit presets
  --------
  >Info
  >Params
  >Layers
  >Tools
>Halp
  >About (popup)
  ---------
  >Open Tutorial


::1/6/2020 windows spec::

-drag from one window to another?
-

data Window = Window {
  innerWidget :: VtyWidget
  , tabName :: Text
}

-- allows dragging/docking windows in the full region
data DockManager = DockManager {
  dockList :: Dynamic [Dock]
  , floatingWindows :: Dynamic [(LBox,Window)]
}

data Tab = OnlyWindow | Tab [Window]

-- only grows vertically because tabs don't make sense horizontally
data Dock = Dock {
  windows :: Dynamic [Tab]
  , location :: LBox
}

:: 12/26/2020 selection spec::
IGNORE-simple select compromise
  -no distinguish between regular select and layer select
  -click drag on selected moves selected
  -folder is single selected and drag folder drags all children
    -during move, needs to add children to selection
      -consider modifying PFMove to move all children as well by default
    -must disallow dropping on an unselected child
  -won't work due to folders
-more complicated select (prob ok?)
  -layers has its own selection
    -canvas selection = layer selection - locked/hidden stuff - folders
  -moving folder auto moves all children
  -selecting folder selects all children (including locked/hidden stuff)
    -however, if any child is unselected this deselect folder
  -canvas selection
    -regular selecting via canvas, overrides layer selection
    -shift selecting via canvas adds to layer selection
    -canvas selecting can never select folders
-full select
  -completely independent canvas and layer selection
  -TODO spec



::1/2020 PARAMS::
box type: {text} box
border: border {label} none
label: <insert label>
alignment: {left} center right
style:
  ‚ïî‚ïê‚ïó
  ‚ïë@‚ïë ‚ñà
  ‚ïö‚ïê‚ïù
line-ends:
<-  ->
^   |
|   v
dimensions:
x: 0  w: 100
y: 50 h: 50


::12/30/2020 orderering service (OS) spec::
  -OS has complete control over PFState
    -insert between PFWorkspace and PFState I guess?
  -OS tracks stack starting from initial state followed by series of actions
  -OS has "previewApply :: Action -> OS -> OS"
  -OS internally has "finalize :: [Action] -> OS -> OS" (acts on last finalized point in history)
    -probably should also return [ActionRef] as list of invalidated Actions
  -PFWorkspace interface
    -userActions :: ActionStack
    -invalidateUserAction :: ActionRef -> ActionStack -> ActionStack
    -undo/redoAction :: ActionStack -> (Action, ActionStack)
  -??? Some way to detect invalid actions ??
    -e.g.
      -A moves X (action A1)
      -B moves X (action B1)
      -A1 should now be invalid action?
    -alternatively, actions are never invalidated, and undo restores SElt state rather than tries to undo the action
  -checkTransitivity :: Action -> Action -> Bool
    -simple implementation to return False if the 2 actions share the same REltId
      -connections can probably be ignored, though they can be tested for too
  -prob need to sync layers as well D:?
    -though doesn't matter if these go out of sync.. still it would be nice to keep these in sync
    -OS can output LayersState that needs to update GoatState
    -can store non-existing entries in LayerMeta so it doesn't need to stay in sync with PFState actions


:: 1/8/2020 layout spec::

## Problem Outline

Tab navigation in the current Layout system does not work when Layouts are nested

For example:

```
col $ do
  -- row 1
  (tile . fixed) 5 $ row $ do
    (tile . fixed) 1 $ someWidget1
    (tile . fixed) 1 $ someWidget2
    (tile . fixed) 1 $ someWidget3
  -- row 2
  (tile . fixed) 5 $ row $ do
    (tile . fixed) 1 $ someWidget4
    (tile . fixed) 1 $ someWidget5
    (tile . fixed) 1 $ someWidget6
```
assume `row1` + `someWidget1` are in focus

The desired behavior is:
  - pressing "tab" will focus `row1` and `someWidget2`
  - pressing "tab" will switch focus from `someWidget<n>` to `someWidget<n+1 mod 6>` and switch focus between `row1` and `row2` as necessary

However, instead we have:
  - pressing "tab" will focus `row2` and `someWidget2`
  - in addition, pressing `tab` again will focus `row1` and `someWidget2`

## Challenges

Broadly speaking, Layout alternates between Layout and VtyWidget and we need to pass data across this boundary in order for tabbing to work as desired.

Using the existing `Layout` module as a starting point, there are 2 major challenges to support the desired behavior outlined above:

1. `runLayout` needs to be aware of nested layout nodes in order to focus the correct tile
2. `tile` needs to be aware of when a particular nested node index should be focus


## Solution

1. is addressed by introducing the new class below. NOTE, `LayoutDebugTree` is discussed later.

```
class IsLayoutReturn t b a where
  getLayoutResult :: b -> a
  getLayoutNumChildren :: b -> Int
  getLayoutFocussedDyn :: b -> Dynamic t (Maybe Int)
  getLayoutTree :: b -> LayoutDebugTree t

instance IsLayoutReturn t (LayoutDebugTree t, Dynamic t (Maybe Int), Int, a) a where
  getLayoutResult (_,_,_,a) = a
  getLayoutNumChildren (_,_,d,_) = d
  getLayoutFocussedDyn (_,d,_,_) = d
  getLayoutTree (tree,_,_,_) = tree

instance Reflex t => IsLayoutReturn t a a where
  getLayoutResult = id
  getLayoutNumChildren _ = 1
  getLayoutFocussedDyn _ = constDyn Nothing
  getLayoutTree _ = emptyLayoutDebugTree
```

2. is address by wrapping the VtyWidget monad with additional contextual information

```
class IsLayoutVtyWidget l t (m :: * -> *) where
  runIsLayoutVtyWidget :: l t m a -> Event t (Maybe Int) -> m a

newtype LayoutVtyWidget t m a = LayoutVtyWidget {
    unLayoutVtyWidget :: ReaderT (Event t (Maybe Int)) (m) a
  } deriving (...)

instance MonadTrans (LayoutVtyWidget t) where
  lift x = LayoutVtyWidget $ lift $ lift x

instance IsLayoutVtyWidget m where
  runIsLayoutVtyWidget w _ = w

instance IsLayoutVtyWidget LayoutVtyWidget t m where
  runIsLayoutVtyWidget = runReaderT . unLayoutVtyWidget
```

Note that since we have `instance LayoutReturn t a a` in 1. and `instance IsLayoutVtyWidget m` in 2. they work with both layout and non-layout nodes.

## Interface Changes

Since focus events now come from the top level layout node, a new method is needed:

```
beginLayout :: LayoutVtyWidget -> VtyWidget
beginLayout child = do
  tab <- tabNavigation
  runLayoutVtyWidget child tab
``

Unfortunately, the interface is not seamless in the case of 1. as the desired monadic return value type is ambiguous as we have both

`IsLayoutReturn t (LayoutDebugTree t, Dynamic t (Maybe Int), Int, a) a`
`IsLayoutReturn t (LayoutDebugTree t, Dynamic t (Maybe Int), Int, a) (LayoutDebugTree t, Dynamic t (Maybe Int), Int, a)`

So we introduce new variants `fixedD` and `stretchD` that make the type deductions above explicit.

## Testing

`LayoutDebugTree` is an optional returned object that contains DynRegion objects of all the children. The intent is to use for automated testing (e.g. get me the absolute coordinates of (5,7) in relative coordinates of the third node of the second node of some `LayoutDebugTree`). I imagine it might be useful in non-testing scenarios as well.

## Code

I've opened up the following draft PR that implements most of the above for discussion.




::handler hierarchy 12/2020::

-if layer above does not handle, input is passed on to layer below
-if NORMAL handler is not active then new selection will set NORMAL handler
-DEFAULT can set NORMAL handler, NORMAL can set OVERRIDE handler

1. LAYERS
2. OVERRIDE
3. NORMAL
4. DEFAULT

ANOTHER OPTION

-handlers return their own overrides
-ESC cancel on override returns back old handler
-no capture input cancel is different than ESC cancel, can't actually undo anything, assert for inactive state

-if no input capture
  -cancel current handler (assert it's not active is enough)
  -create DefaultHandler
  -pass onto DefaultHandler
  -Default handler returns whatever handler as its own override
  -ok but do I Really need to do this? current case statement is fine
-new selection overrides handler if handler is not active



::Handler Notes 12/2020::

-PROBLEM can't respond to PFOutput
  -SEltLabelChanges happen in backend and aren't avail in frontend
    -currently we just query PFState and don't need the changes
      -could stash a copy of changes to query in backend if we really needed them to update I guess
    -render event can be triggered from changes so it always has access to most up to date version
    -handleChanges method not possible I think...
      -yes, if you do it in backend... then pass it to frontend...
  -selection stored in back end and not accessible in frontend D:
    -see above
    -store handler in backend then D:? Annoying, next handler needs to be passed from frontend....
      -more like override handler? idk...

-invariants
  -selection does not change throughout lifetime of a handler
    -"handler lifetime" = chain of handlers returned by pHandelXYZ operations

-handler creation/update cases
  -uncaptured input
  -new selection
    -Ughh, selection isn't so good because you get a new selection for each change during a drag D:
      DONE-could resolve by not generating new REltIds but I think this is not so good
      -maybe OK now??
      -just need to track REltId in handler I guess??
  -how about handleChange :: ... -> SEltLabelChanges -> ...
    -you will need this anyways to update manipulators after changes from PFOutput??


-handler cancel cases
  -escape cancel
  -input falls through and new handler created thus cancelling oldo ne
  -new selection creates new handler

-handler input cases
  -captures
    -does nothing
    -updates handler state
    -returns different handler
    -returns new selections
    -return new event
  -does not capture
    -input possible passed to new handler
      -in which case old handler gets canceled
    -input gets consumed by non-handler operation
      -may trigger events to update selection and create new handler
    -input gets ignored

-auto create handler based on selection when handler is cleared
  -we need to do this so that if we start creating a new handler and then cancel, we want to get the default selection based handler back
    -this is not ideal though because if we have sub modal handlers (e.g. text editting mode) that handler info gets loss
      -I guess you could solve this with "lastHandler" or some kind of handler stack D:



:::::::::::::::::::::::::::::::::::::::
:::::PRE MEGA REFACTOR STUFF BELOW:::::
:::::::::::::::::::::::::::::::::::::::


stack build --profile --ghc-options="-ddump-prep -ddump-to-file"
stack exec --profile -- memorytests +RTS -hd
hp2ps -e8in -c memorytests.hp


stack ghci potato-flow:potato-flow-test
:set -fbreak-on-exception


:: DATA REFACTOR NOTES ::
IGNORE-Add REltId to SElt
-get rid of NonEmpty in PFCmd
-add assert to check LayerPos boundary stuff
  -make sure asserts actually work
DONE-clipboard should exist outside of workspace



::SEltLayers refactor notes::

_sEltLayerTree_view         :: Dynamic t (Seq REltId)

-- TODO BPTREE TRACKS previous SEltLabel, so prob don't need to return it :o
, _sEltLayerTree_changeView :: Event t (REltIdMap (Maybe SEltLabel, Maybe SEltLabel)) -- elements that were added, moved, or deleted
, _directory_contents   :: Dynamic t (REltIdMap SEltLabel)

, _sEltLayerTree_reverseMap   :: Dynamic t (LayerPosMap)
, _sEltLayerTree_copied     :: Dynamic t (Seq SEltLabel)
, _sEltLayerTree_potato_state :: Dynamic t [SEltLabel]

_sEltLayerTreeConfig_insert               :: Event t (NonEmpty SuperSEltLabel)
, _sEltLayerTreeConfig_remove             :: Event t (NonEmpty SuperSEltLabel)
, _sEltLayerTree_directory_doManipulate   :: Event t ControllersWithId
, _sEltLayerTree_directory_undoManipulate :: Event t ControllersWithId
, _sEltLayerTreeConfig_load               :: Event t [(REltId, SEltLabel)]

, _sEltLayerTreeConfig_move :: Event t (NonEmpty (LayerPos, LayerPos)) -- TODO figure out rules on indexing, I think destination indexes probably need to be in order
, _sEltLayerTreeConfig_copy :: Event t (NonEmpty LayerPos)
, _sEltLayerTreeConfig_duplicate


::RELEASES::
-MVP alpha 0
  -straight lines
  -inverted LBox
  -layer reorder + rename
  -multi-select / modify
  -save/load (potato interface)
  -render to text file
  -param styles
-alpha 1
  -multilines
  -text box
  -out of boundary rendering
  -maybe refactor SEltLayers and finish BroadPhase
  -copypasta
  -duplicate
  -real interface for save/load
-alpha 2
  -folders
  -visibility/lock
-alpha 3
  -attachment points
  -groups


::NEW TODO::
-add testing for sEltLabelChanges
-get rid of SEltTree or rename to SEltLableTree
  -mayeb even use newtype wrapper to better ensure scoping property
-get asserts working
-switch all PARTIALs to use asserts so they give you line numbers...
-try this thing: compile reflex with flag 'debug-cycles' and compile with profiling enabled for stack tree
-textstyle
  -option for space characters to be transparent
-multi-line stuff
  -V/H/V/H alternating
  -manipulators are on the line (I guess you can do corners too)
-SEltLayers
  -redo SEltLayers with bespoke structure so everything can be done in one frame D:
  -move command
  -REltId -> Index map
-mid priority
  IGNORE-helpers to create fine grained manipulators
  -refine drawers
  -add interface for multi delete and test
  -add interface for multi add and test
  -add max length param to actionstack
  DONE-backend render stuff
    DONE-just do super basic render everything version for now, since we are refactoring math

IGNORE/DONE-add postbuild back into reflex-test-host
IGNORE/FAIL-remove spiderhost constraints in reflex-test-host
DONE-add support for move in Testing.hs
DONE-test copypasta
DONE-move
  DONE-switch to use testable methods in Layers
  DONE-write test for undo move

:: WISH LIST ::
-FUTURE folders should have a grouping tag. If any single element in group is selected all elements are selected
  -but this mean you also need a recursive focus mode, that ungroups grouped elements and only allows you to edit those elements
-Attaching lines and attachment points
-line style/thickness :D

::ATTACHING::
-getSEltAttachPoints :: SElt -> IntMap XY
  -key is attach id, XY is position
-_sSimpleLine_attachments :: (Maybe (REltId, Int), Maybe (REltId, Int))
  -attach points for each end of the line, really you should use an Either
    -or another option is to have both attach and hard values, and ensure they are always in sync
-type AttachMap = REltIdMap [REltId]
  -map of REltIds attached to given REltId
-dynamics
  -CLine has parameter to attach to (REltId, Int)
  -changes that have attach (or removing attach) modify a Dynamic AttachMap
  -after modifying a REltId, all attached things are reported as modified as well
-helper method to convert attachments into hard values
-some way to render possible attachment points when you hover over something that can be attached to
  -also a modifier key to move to a position without attaching
-problems: Do I need to serialize REltId?
  -kinda don't want to, you can relabel or use layer pos as serialized id
    -this works, but you need to do a pass on the id's during serialization/deserialization to change between LayerPos and REltId. Sort of abuse of the variable but it works

:: OLD TODO ::
IGNORE-consider hiding manipulators if tool is incorrect (i.e. not select tool)
IGONRE-manipulators
  DONE-get negative boxes working
  -do MBoundingBox manipulator
    -use same code as MBox, but different behavior based on manipulateImmediately
  -move create new elt into manipulator
  DONE-do one big manipulator for translating thing
    -click+drag should ideally go straight to move if it selects
      -anyway to use the same bool in selectFromVeryNew? Maybe rename the bool to manipulateImmediately which is interpreted by each manipulator differently
DONE/IGNORE-low priority
  -see if microlens gets inlined and decide to use it if so
  IGNORE-modify SEltLayers/Directory/DirectoryIdAssigner so it's not using NonEmpty
    -assert warning if empty
  IGNORE-rename relt
  IGNORE-add deriveGCompare1/GEq1 to Data.GADT.Compare.TH
  IGNORE-use affine transformations for box manipulation

DONE/IGNORE-make sure
  DONE-canvas pane does not get mouse inputs from other places
  -focus switches properly between layer and canvas panes (for key events)
DONE-pane not registering mouse up events that happen off pane
  DONE-probably have to make your own dragging stuff
  DONE-probably need to add Reader monad to pipe global events through everything
  IGNORE-maybe you could change HasVtyInput so it ignores dragging events that happen from off the screen?
DONE-refactor math?
DONE-controller refactor bleh
  DONE-figure out how to handle negative coordinates
  DONE-figure out how to handle CTagRelBox
    -rename to CTagBoundingBox
    -you could just keep precise before/after deltas for everything
  DONE-rename vars in Controllers to indicate they are deltas
DONE-refactor into several files D:
DONE-L/R panes, resizeable (implement splitH)
DONE-canvas
  -data
    -CursorState = Selecting | Selected | Manipulating | Panning | NewBox | NewLine ...
    -Dynamic t CursorState
    -New -> runWithReplace (makeManipulatorFromNewElt) sEltTree_changeView
DONE-add + manipulate = 2 actions issue D:
  -new workflow is:
    -tool click ev -> create manipulator -> add widget with initial size
    -selected ev -> create manipulator -> modify widget
DONE-add mem leak test
DONE-take CAREFUL note that sequenceEvents outside of potato-flow might break stuff if it's used internally
  -perhaps move undo do modify inside of potato-flow so there's no incorrect usage from outside
DONE-add mem leak test
DONE-workspace stuff (for now just support 1 workspace)
  DONE-canvas support
  DONE-resize canvas command
  DONE-load SEltTree
    -add test to save and reload and ensure state stays the same
IGNORE-canvas needs a clear method
DONE-decide if you want _pfo_saved or _pfo_potato_state
  -have to keep _pfo_potato_state until render stuffis done properly
DONE-setup frontend from potato-flow
DONE-test multi-modify
DONE-fix mem leak
  -just add multi insert support into seq for easy fix
  -harder fix is actually understand what is going on D:
DONE-sharing
  -clean up doc in dynamics and put on hackage?
  -clean up docs in test and put on hackage?
    -maybe need to add or remove some interfaces
IGNORE-write profilingWidget which takes an event, calls GHC.Stats, and outputs results
DONE-state serializers (should be done, just need to hook up aeson and test)
DONE-figure out deriveArgDict thing, we need show instances for debugging!!
IGNORE-switch bulk manipulation to send manipulators per box, one big box method doesn't work for undo due to roundoff
  -or maybe I'm wrong?
DONE-testing stuff
  DONE-basic support for input/expected output pair testing
  DONE-add undo redo test
  DONE-add memtest
DONE-test for rest of controller stuff
  -refine testing interface so you can modify individual elts
DONE-move directory out of dynamics and into here
DONE-split out test methods into a module
DONE-undo/redo test
DONE-mem test
DONE-fix modify stuff, it's broken :(
DONE-switch to linear for Math
  -package Math into a separate lib on stackage plz
  -rename stuff a little
DONE-finish selt stuff
  -toManipulator
  -updateFnFromController
DONE-manipulator test
DONE-hook up manipulators
DONE-refactor
  -make naming in selts consistent with rest of code
IGNORE-do the reusing manipulators trick
DONE-Q selective rendering
  -upon modifying or deleting an element, we need to know its PREVIOUS state as well to know what needs to be rerendered
    -we need type `PatchIntMap (Maybe SEltLabel, Maybe SEltLabel)`
DONE-new relt factory
  -owns directory id assigner
  -inputs
    -new selt
    -paste/duplicate
    -undo remove
  -outputs
    -new elt :: [(LayerPos, ReltId, SElt)]
DONE-put directory and layers together
  -inputs
    -do/undo mainpulate
      -use traverseIntMapPatchWithKey (where patch contains deltas)
    -do remove
    -do/undo move
    -new elt
  -outputs
    -modified :: PatchIntMap SElt
    -layers :: Seq LayerEltId
    -all :: IntMap SElt
DONE-reusing manipulators
  -Dynamic [(LayerEltId,SEltLabel)]
    -fmapMaybe if only 1
      -fan by SElt type to manipulator
    -fmapMaybe if many
      -manipulatemany
DONE-update new testing framework to match Test.Run in reflex
DONE-update test cases to use new testing framework
DONE-consider refactoring relts so they don't contain dynamics
IGNORE-finish relt deserializers
IGNORE-hook up manipulators? (or did I do this already)
DONE-start reflex project
DONE-move directory into layer
  -or just delete it for now, prob ok?
DONE-delete reflex basic host from github or add a pointer to this repo
IGNORE-use default instances for config
DONE-figure out unicode in todo undo dom
DONE-make reflex-test-app Reflex.Test.App package
DONE-make reflex-potato-containers package
DONE-consider making reflex-potato-helpers package
DONE-try with -o2 for leaks
DONE-profile memory usage
IGNORE-consider adding maybe event to configs instead of using never :o
DONE-rename gitrepo to potato-flow
DONE-decide what to do with directory and LayerEltIds
  DONE-are LayerEltIds even needed? We can just pass in the full RElt reference
      -YES they are needed to fan events efficiently
  DONE-how to reverse map RElts to their layer positions
    DONE-or we can require front end to always pass in layer positions
      -YES as if layer position was time sensitive relt id (except it's serializes and changes)
    -this is where the seq implementation was not such a great idea
  DONE-connect remove event
DONE-connect do events to action stack in entry
DONE-remove import qualified Data.Sequence         as Seq
DONE-actually you do need a separate MControl type
IGNORE-get rid of REltFactory
DONE-high priority
  DONE-write Reflex.Data.Seq
  DONE-layertree
    -implement
    IGNORE-decide move semantics (indexing is before or after)
  DONE-create simple test app!!

DONE-id assigner
  -ids need to be obtained first before relt is created as relt needs to know its id to select its events
DONE-clean up DirectoryIdAssigner interface and tests
DONE-action input distributor
DONE-action output collector
DONE-connect layer tree in entry
DONE-fan out/in actions for actionstack in entry
DONE-manipulators
  DONE-design


::RENDER NOTES::
-inputs
  -layers :: Behavior t (Seq REltId)
  -seltls :: Behavior t (Map REltId SEltLabel)
  -changes :: Map REltId (Maybe SEltLabel, Maybe SEltLabel)
  -location :: Behavior t (Map REltId LayerPos)
-data
  -BPTree (for now just do Map REltId AABB)
  -Canvas = Canvas (Vector Char) Int
    - use REPA instead?
-methods
  -getAABB :: SEltLabel -> AABB
  -render :: SEltLabel -> LPoint -> Maybe Char
  -insert/updated :: BPTree -> (REltId, AABB) -> BPTree
  -broadPhase :: BPTree -> AABB -> [REltId]
  -render :: AABB -> [SEltLabel] -> Canvas -> Canvas
-reflex
  -changes -> insert/update
  -changes -> getAABBs -> broadPhase -> Event t [REltId]
    -> fmap (sortBy location) -> render

::OLD STUFF::

-feature creep 0
  -save/load workspace
    -clear workspace
  -multi select
    -multi delete
    -multi manipulate
  -move
-feature creep 1
  -PFCReorder :: PFCmdTag t (LayerEltId, LayerPos)
-feature creep 2
  -copy pasta
  -PFCPaste :: PFCmdTag t ([SElt t], LayerPos)
  -PFCDuplicate :: PFCmdTag t [LayerEltId]
  -deleting/moving layer elts that are not in order
-feature creep 3
  -connected elts
  -RElt manipulators now require readonly hooks into existing RElts
    -connected :: Dynamic t LayerEltId
    -reltUpdateds :: Dynamic t (DMap (Const2 LayerEltId REltLabel) Identity)
    -connectedUpdates' :: fmap (\i -> select i . fan reltUpdates) connected :: Event t [Event t REltLabel]
    -connectedUpdateds :: sequence . switch $ ConnectedUpdates' :: Event t [REltLabel t]
    -now you can set manipulators based on new relt positions
      -be sure the set operations are reversible
        -this way if we undo an action on a connected element state is still as expected
        -don't forget about delete events!

::NEW QUESTIONS::
-do I use repeatEvent trick to move multiple elements or support interface that does it directly?
  -probably do it with repeatEvent first and switch later for performance or if you can't figure out repeatEvent nonsense

-all actions to change RElts go through manipulator

-REltFactory needs to pass on layer pos information for where the SEltTree is going to be inserted D:

DONE-REltDirectory needs to prune old RElts to trigger GC on them
  -removed RElts might get added back in and we want them to have the same ID
    THIS-we could either require remove operation to carry RElt reference
    -or we could add prune operation to actions that get removed from action stack

---------
I did a little research myself and found no pure reactive data structure libraries out there. The closest thing I found was: https://hackage.haskell.org/package/reflex-dom-retractable which is a reactive stack. However events are routed through performEvent in the IO monad.

I simplified the problem at hand a little for myself and decided a dynamic list should be sufficient.

I went ahead and implemented + tested this:

For zippers, static indices are sufficient. They are partial and very execution order dependent (i.e. because indices change after each update)

I think one could make dynamic indices into the list if you need execution order independence.

Or, I can add (Eq a) constraint to uniquely identify elements in the list to solve this problem.
I found this library which sorta solves this problem http://hackage.haskell.org/package/reflex-transformers-0.2.1/docs/Reflex-Monad-Supply.html

------
::MAJOR QUESTIONS::
-elt tree
  NO-need some sort of zipper or map into nodes
    -how to do zipper over dynamic lists?
      -doable, but each zipper is O(n)
    -another way to have static zippers that get destroyed each time the tree changes
      -[REltTree t] list of parents leading up to the node
      -prob still need UUID in each node to do comparison
      -not so great for our selection system
  -another option is to give each node a UUID upon creation, and then store a map to existing nodes
    -this would be simpler
  -maybe there is a simpler way just to hold refs to the RElts
-groupable elt list then?
  -groups can be defined by start and end elt

-manipulators
  -

-actions
  -each manipulator is connected to elt params and has events to update it
    -e.g. boxEvent :: SBoxManipulator -> (Event t LPoint, Event t LSize)
  -front-end connects to behavior and events
    -e.g. elt behaviors => front-end =interaction=> manipulator events => elt behaviors
  -SBoxManipulator will create events of the following type:
    Event t (Action )
  -undo/redo :: Event t () -> Dynamic (Stack Action) -> Event Action

-restructuring elt tree
  -start with
    `deleteSelectedEvent :: Event t ()`
    `moveEvent :: Event t EltRef`
    `addEvent :: Event t (EltRef, ??)` -- need to figure out how to create new elts
  -pass through
    `selection :: Dynamic [EltRef]`
  -on constructing children of elt x
    -children hooks into delete/move events
    -each node also has its own delete self event which is called for GC purposes


-updating elts

-elt
  -add child event
  -remove child event


::UI STUFF::
-selection
  -select event
      -select in screen
      -select in layers
  -screen
    -if only 1 elt selected
      -use manipulator UI?
    -if many selected
      -use generic manipulator?


::DESIGN::



::mouse states::
-active
  -in active state, an action is staged and continuously do/undo a it's being updated
  -once leaving active state, action is moved onto stack and executed

::manipulator::

::elements + layers::
-empty elt (like unity)
  -empty elt approach disadvantage is folders do not care about position and have no manipulators etc

::main events::
eltList :: Dynamic Elt -- top level elements

::elt events::
-listening
  destroyed :: Event () <- is this even needed?

::trigger events::
save :: () -> IO ()
load :: Text -> IO ()
