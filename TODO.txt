::NEWEST TODO::
-line manipulators
-layers
  -decide where to store layer state
  -layer drag interface (mouse position or more abstract?)
-text manipulators
  -idk D: make your own zip, how bad could it be
  -decide how to handle wrap/overflow
  -selecting text defines the text mainpulator that covers the whole place
    -click again on text mainpulator updates it (where to store text zipper cursor pos?)
      -live metadata? Or you can even serialize it with folder stuff
    -click drag does nothing (or selects D: maybe not)
    -click off deselects
-broadphase tests
-connect RenderedCanvas

DONE-look into doing pending selection for immediate select + manipulate
  DONE-add test for single click select + actually manipulate
DONE-proper cancelling (maybe add new state var to ignore mouse stuff?)
  DONE-fix cancel tests so that they try and do stuff after the cancel
DONE-manipulate tests
  DONE-test cancel in creation case
  DONE-test cancel in manipulate case
DONE-correct manipulator so it takes selection directly in front end
  -manipulate :: MosueDrag -> (SelectionManipulatorType, MouseManipulatorSet, ManipulatorIndex) -> (ManipulatorIndex, Maybe Controller)
DONE-create separate file for manipulator test
  -maybe improve testing framework a little to have more helpers for testing elts (and giving them names)
DONE-switch to makeManipulationController
DONE-sepearet mouse stuff out of Everything
DONE-seperate Manipulator out of Everything
DONE-remove reflex folder, Entry goes into Flow folder
DONE-figure out manipulator drag through another manipulator issue
  -also we want a general interface for all types of manipulators
DONE-add modifiers to LMouseData
DONE-undo first does not reset RID counter for some reason
DONE-selection tests
  DONE-basic
  DONE-test cancel
  DONE-test add/noadd to select
  DONE-test single click select
DONE-fix memory leak again ;__;
DONE-need to use doCmdPFTTotalStateUndoFirst inside Entry
  -only need for addElt, manipulateElt and maybe resizeCanvas
DONE/IGNORE-redo manipulator storage in everything
  -list of manipulators
  -you need a better way to track which is the active manipulator
    -instead of iterating trhough thelist... though maybe that's not the worst
  -here is how it should work:
    -selection -> indexed list of manipulators + drag delta function
DONE-hook up PF
  DONE-pass in initial state into EverythingFrontend
  -prob output PF in EverythingBackend
DONE-manipulatingDyn can be moved into backend

:::::::::::::::::::::::::::::::::::::::
:::::PRE MEGA REFACTOR STUFF BELOW:::::
:::::::::::::::::::::::::::::::::::::::


stack build --profile --ghc-options="-ddump-prep -ddump-to-file"
stack exec --profile -- memorytests +RTS -hd
hp2ps -e8in -c memorytests.hp


stack ghci potato-flow:potato-flow-test
:set -fbreak-on-exception


:: DATA REFACTOR NOTES ::
IGNORE-Add REltId to SElt
-get rid of NonEmpty in PFCmd
-add assert to check LayerPos boundary stuff
  -make sure asserts actually work
DONE-clipboard should exist outside of workspace



::SEltLayers refactor notes::

_sEltLayerTree_view         :: Dynamic t (Seq REltId)

-- TODO BPTREE TRACKS previous SEltLabel, so prob don't need to return it :o
, _sEltLayerTree_changeView :: Event t (REltIdMap (Maybe SEltLabel, Maybe SEltLabel)) -- elements that were added, moved, or deleted
, _directory_contents   :: Dynamic t (REltIdMap SEltLabel)

, _sEltLayerTree_reverseMap   :: Dynamic t (REltIdMap LayerPos)
, _sEltLayerTree_copied     :: Dynamic t (Seq SEltLabel)
, _sEltLayerTree_potato_state :: Dynamic t [SEltLabel]

_sEltLayerTreeConfig_insert               :: Event t (NonEmpty SuperSEltLabel)
, _sEltLayerTreeConfig_remove             :: Event t (NonEmpty SuperSEltLabel)
, _sEltLayerTree_directory_doManipulate   :: Event t ControllersWithId
, _sEltLayerTree_directory_undoManipulate :: Event t ControllersWithId
, _sEltLayerTreeConfig_load               :: Event t [(REltId, SEltLabel)]

, _sEltLayerTreeConfig_move :: Event t (NonEmpty (LayerPos, LayerPos)) -- TODO figure out rules on indexing, I think destination indexes probably need to be in order
, _sEltLayerTreeConfig_copy :: Event t (NonEmpty LayerPos)
, _sEltLayerTreeConfig_duplicate


::RELEASES::
-MVP alpha 0
  -straight lines
  -inverted LBox
  -layer reorder + rename
  -multi-select / modify
  -save/load (potato interface)
  -render to text file
  -param styles
-alpha 1
  -multilines
  -text box
  -out of boundary rendering
  -maybe refactor SEltLayers and finish BroadPhase
  -copypasta
  -duplicate
  -real interface for save/load
-alpha 2
  -folders
  -visibility/lock
-alpha 3
  -attachment points
  -groups


::NEW TODO::
-add testing for sEltLabelChanges
-get rid of SEltTree or rename to SEltLableTree
  -mayeb even use newtype wrapper to better ensure scoping property
-get asserts working
-switch all PARTIALs to use asserts so they give you line numbers...
-try this thing: compile reflex with flag 'debug-cycles' and compile with profiling enabled for stack tree
-textstyle
  -option for space characters to be transparent
-multi-line stuff
  -V/H/V/H alternating
  -manipulators are on the line (I guess you can do corners too)
-SEltLayers
  -redo SEltLayers with bespoke structure so everything can be done in one frame D:
  -move command
  -REltId -> Index map
-mid priority
  IGNORE-helpers to create fine grained manipulators
  -refine drawers
  -add interface for multi delete and test
  -add interface for multi add and test
  -add max length param to actionstack
  DONE-backend render stuff
    DONE-just do super basic render everything version for now, since we are refactoring math

IGNORE/DONE-add postbuild back into reflex-test-host
IGNORE/FAIL-remove spiderhost constraints in reflex-test-host
DONE-add support for move in Testing.hs
DONE-test copypasta
DONE-move
  DONE-switch to use testable methods in Layers
  DONE-write test for undo move

:: WISH LIST ::
-FUTURE folders should have a grouping tag. If any single element in group is selected all elements are selected
  -but this mean you also need a recursive focus mode, that ungroups grouped elements and only allows you to edit those elements
-Attaching lines and attachment points
-line style/thickness :D

::ATTACHING::
-getSEltAttachPoints :: SElt -> IntMap XY
  -key is attach id, XY is position
-_sLine_attachments :: (Maybe (REltId, Int), Maybe (REltId, Int))
  -attach points for each end of the line, really you should use an Either
    -or another option is to have both attach and hard values, and ensure they are always in sync
-type AttachMap = REltIdMap [REltId]
  -map of REltIds attached to given REltId
-dynamics
  -CLine has parameter to attach to (REltId, Int)
  -changes that have attach (or removing attach) modify a Dynamic AttachMap
  -after modifying a REltId, all attached things are reported as modified as well
-helper method to convert attachments into hard values
-some way to render possible attachment points when you hover over something that can be attached to
  -also a modifier key to move to a position without attaching
-problems: Do I need to serialize REltId?
  -kinda don't want to, you can relabel or use layer pos as serialized id
    -this works, but you need to do a pass on the id's during serialization/deserialization to change between LayerPos and REltId. Sort of abuse of the variable but it works

:: OLD TODO ::
IGNORE-consider hiding manipulators if tool is incorrect (i.e. not select tool)
IGONRE-manipulators
  DONE-get negative boxes working
  -do MBoundingBox manipulator
    -use same code as MBox, but different behavior based on manipulateImmediately
  -move create new elt into manipulator
  DONE-do one big manipulator for translating thing
    -click+drag should ideally go straight to move if it selects
      -anyway to use the same bool in selectFromVeryNew? Maybe rename the bool to manipulateImmediately which is interpreted by each manipulator differently
DONE/IGNORE-low priority
  -see if microlens gets inlined and decide to use it if so
  IGNORE-modify SEltLayers/Directory/DirectoryIdAssigner so it's not using NonEmpty
    -assert warning if empty
  IGNORE-rename relt
  IGNORE-add deriveGCompare1/GEq1 to Data.GADT.Compare.TH
  IGNORE-use affine transformations for box manipulation

DONE/IGNORE-make sure
  DONE-canvas pane does not get mouse inputs from other places
  -focus switches properly between layer and canvas panes (for key events)
DONE-pane not registering mouse up events that happen off pane
  DONE-probably have to make your own dragging stuff
  DONE-probably need to add Reader monad to pipe global events through everything
  IGNORE-maybe you could change HasVtyInput so it ignores dragging events that happen from off the screen?
DONE-refactor math?
DONE-controller refactor bleh
  DONE-figure out how to handle negative coordinates
  DONE-figure out how to handle CTagRelBox
    -rename to CTagBoundingBox
    -you could just keep precise before/after deltas for everything
  DONE-rename vars in Controllers to indicate they are deltas
DONE-refactor into several files D:
DONE-L/R panes, resizeable (implement splitH)
DONE-canvas
  -data
    -CursorState = Selecting | Selected | Manipulating | Panning | NewBox | NewLine ...
    -Dynamic t CursorState
    -New -> runWithReplace (makeManipulatorFromNewElt) sEltTree_changeView
DONE-add + manipulate = 2 actions issue D:
  -new workflow is:
    -tool click ev -> create manipulator -> add widget with initial size
    -selected ev -> create manipulator -> modify widget
DONE-add mem leak test
DONE-take CAREFUL note that sequenceEvents outside of potato-flow might break stuff if it's used internally
  -perhaps move undo do modify inside of potato-flow so there's no incorrect usage from outside
DONE-add mem leak test
DONE-workspace stuff (for now just support 1 workspace)
  DONE-canvas support
  DONE-resize canvas command
  DONE-load SEltTree
    -add test to save and reload and ensure state stays the same
IGNORE-canvas needs a clear method
DONE-decide if you want _pfo_saved or _pfo_potato_state
  -have to keep _pfo_potato_state until render stuffis done properly
DONE-setup frontend from potato-flow
DONE-test multi-modify
DONE-fix mem leak
  -just add multi insert support into seq for easy fix
  -harder fix is actually understand what is going on D:
DONE-sharing
  -clean up doc in dynamics and put on hackage?
  -clean up docs in test and put on hackage?
    -maybe need to add or remove some interfaces
IGNORE-write profilingWidget which takes an event, calls GHC.Stats, and outputs results
DONE-state serializers (should be done, just need to hook up aeson and test)
DONE-figure out deriveArgDict thing, we need show instances for debugging!!
IGNORE-switch bulk manipulation to send manipulators per box, one big box method doesn't work for undo due to roundoff
  -or maybe I'm wrong?
DONE-testing stuff
  DONE-basic support for input/expected output pair testing
  DONE-add undo redo test
  DONE-add memtest
DONE-test for rest of controller stuff
  -refine testing interface so you can modify individual elts
DONE-move directory out of dynamics and into here
DONE-split out test methods into a module
DONE-undo/redo test
DONE-mem test
DONE-fix modify stuff, it's broken :(
DONE-switch to linear for Math
  -package Math into a separate lib on stackage plz
  -rename stuff a little
DONE-finish selt stuff
  -toManipulator
  -updateFnFromController
DONE-manipulator test
DONE-hook up manipulators
DONE-refactor
  -make naming in selts consistent with rest of code
IGNORE-do the reusing manipulators trick
DONE-Q selective rendering
  -upon modifying or deleting an element, we need to know its PREVIOUS state as well to know what needs to be rerendered
    -we need type `PatchIntMap (Maybe SEltLabel, Maybe SEltLabel)`
DONE-new relt factory
  -owns directory id assigner
  -inputs
    -new selt
    -paste/duplicate
    -undo remove
  -outputs
    -new elt :: [(LayerPos, ReltId, SElt)]
DONE-put directory and layers together
  -inputs
    -do/undo mainpulate
      -use traverseIntMapPatchWithKey (where patch contains deltas)
    -do remove
    -do/undo move
    -new elt
  -outputs
    -modified :: PatchIntMap SElt
    -layers :: Seq LayerEltId
    -all :: IntMap SElt
DONE-reusing manipulators
  -Dynamic [(LayerEltId,SEltLabel)]
    -fmapMaybe if only 1
      -fan by SElt type to manipulator
    -fmapMaybe if many
      -manipulatemany
DONE-update new testing framework to match Test.Run in reflex
DONE-update test cases to use new testing framework
DONE-consider refactoring relts so they don't contain dynamics
IGNORE-finish relt deserializers
IGNORE-hook up manipulators? (or did I do this already)
DONE-start reflex project
DONE-move directory into layer
  -or just delete it for now, prob ok?
DONE-delete reflex basic host from github or add a pointer to this repo
IGNORE-use default instances for config
DONE-figure out unicode in todo undo dom
DONE-make reflex-test-app Reflex.Test.App package
DONE-make reflex-potato-containers package
DONE-consider making reflex-potato-helpers package
DONE-try with -o2 for leaks
DONE-profile memory usage
IGNORE-consider adding maybe event to configs instead of using never :o
DONE-rename gitrepo to potato-flow
DONE-decide what to do with directory and LayerEltIds
  DONE-are LayerEltIds even needed? We can just pass in the full RElt reference
      -YES they are needed to fan events efficiently
  DONE-how to reverse map RElts to their layer positions
    DONE-or we can require front end to always pass in layer positions
      -YES as if layer position was time sensitive relt id (except it's serializes and changes)
    -this is where the seq implementation was not such a great idea
  DONE-connect remove event
DONE-connect do events to action stack in entry
DONE-remove import qualified Data.Sequence         as Seq
DONE-actually you do need a separate MControl type
IGNORE-get rid of REltFactory
DONE-high priority
  DONE-write Reflex.Data.Seq
  DONE-layertree
    -implement
    IGNORE-decide move semantics (indexing is before or after)
  DONE-create simple test app!!

DONE-id assigner
  -ids need to be obtained first before relt is created as relt needs to know its id to select its events
DONE-clean up DirectoryIdAssigner interface and tests
DONE-action input distributor
DONE-action output collector
DONE-connect layer tree in entry
DONE-fan out/in actions for actionstack in entry
DONE-manipulators
  DONE-design


::RENDER NOTES::
-inputs
  -layers :: Behavior t (Seq REltId)
  -seltls :: Behavior t (Map REltId SEltLabel)
  -changes :: Map REltId (Maybe SEltLabel, Maybe SEltLabel)
  -location :: Behavior t (Map REltId LayerPos)
-data
  -BPTree (for now just do Map REltId AABB)
  -Canvas = Canvas (Vector Char) Int
    - use REPA instead?
-methods
  -getAABB :: SEltLabel -> AABB
  -render :: SEltLabel -> LPoint -> Maybe Char
  -insert/updated :: BPTree -> (REltId, AABB) -> BPTree
  -broadPhase :: BPTree -> AABB -> [REltId]
  -render :: AABB -> [SEltLabel] -> Canvas -> Canvas
-reflex
  -changes -> insert/update
  -changes -> getAABBs -> broadPhase -> Event t [REltId]
    -> fmap (sortBy location) -> render

::OLD STUFF::

-feature creep 0
  -save/load workspace
    -clear workspace
  -multi select
    -multi delete
    -multi manipulate
  -move
-feature creep 1
  -PFCReorder :: PFCmdTag t (LayerEltId, LayerPos)
-feature creep 2
  -copy pasta
  -PFCPaste :: PFCmdTag t ([SElt t], LayerPos)
  -PFCDuplicate :: PFCmdTag t [LayerEltId]
  -deleting/moving layer elts that are not in order
-feature creep 3
  -connected elts
  -RElt manipulators now require readonly hooks into existing RElts
    -connected :: Dynamic t LayerEltId
    -reltUpdateds :: Dynamic t (DMap (Const2 LayerEltId REltLabel) Identity)
    -connectedUpdates' :: fmap (\i -> select i . fan reltUpdates) connected :: Event t [Event t REltLabel]
    -connectedUpdateds :: sequence . switch $ ConnectedUpdates' :: Event t [REltLabel t]
    -now you can set manipulators based on new relt positions
      -be sure the set operations are reversible
        -this way if we undo an action on a connected element state is still as expected
        -don't forget about delete events!

::NEW QUESTIONS::
-do I use repeatEvent trick to move multiple elements or support interface that does it directly?
  -probably do it with repeatEvent first and switch later for performance or if you can't figure out repeatEvent nonsense

-all actions to change RElts go through manipulator

-REltFactory needs to pass on layer pos information for where the SEltTree is going to be inserted D:

DONE-REltDirectory needs to prune old RElts to trigger GC on them
  -removed RElts might get added back in and we want them to have the same ID
    THIS-we could either require remove operation to carry RElt reference
    -or we could add prune operation to actions that get removed from action stack

---------
I did a little research myself and found no pure reactive data structure libraries out there. The closest thing I found was: https://hackage.haskell.org/package/reflex-dom-retractable which is a reactive stack. However events are routed through performEvent in the IO monad.

I simplified the problem at hand a little for myself and decided a dynamic list should be sufficient.

I went ahead and implemented + tested this:

For zippers, static indices are sufficient. They are partial and very execution order dependent (i.e. because indices change after each update)

I think one could make dynamic indices into the list if you need execution order independence.

Or, I can add (Eq a) constraint to uniquely identify elements in the list to solve this problem.
I found this library which sorta solves this problem http://hackage.haskell.org/package/reflex-transformers-0.2.1/docs/Reflex-Monad-Supply.html

------
::MAJOR QUESTIONS::
-elt tree
  NO-need some sort of zipper or map into nodes
    -how to do zipper over dynamic lists?
      -doable, but each zipper is O(n)
    -another way to have static zippers that get destroyed each time the tree changes
      -[REltTree t] list of parents leading up to the node
      -prob still need UUID in each node to do comparison
      -not so great for our selection system
  -another option is to give each node a UUID upon creation, and then store a map to existing nodes
    -this would be simpler
  -maybe there is a simpler way just to hold refs to the RElts
-groupable elt list then?
  -groups can be defined by start and end elt

-manipulators
  -

-actions
  -each manipulator is connected to elt params and has events to update it
    -e.g. boxEvent :: SBoxManipulator -> (Event t LPoint, Event t LSize)
  -front-end connects to behavior and events
    -e.g. elt behaviors => front-end =interaction=> manipulator events => elt behaviors
  -SBoxManipulator will create events of the following type:
    Event t (Action )
  -undo/redo :: Event t () -> Dynamic (Stack Action) -> Event Action

-restructuring elt tree
  -start with
    `deleteSelectedEvent :: Event t ()`
    `moveEvent :: Event t EltRef`
    `addEvent :: Event t (EltRef, ??)` -- need to figure out how to create new elts
  -pass through
    `selection :: Dynamic [EltRef]`
  -on constructing children of elt x
    -children hooks into delete/move events
    -each node also has its own delete self event which is called for GC purposes


-updating elts

-elt
  -add child event
  -remove child event


::UI STUFF::
-selection
  -select event
      -select in screen
      -select in layers
  -screen
    -if only 1 elt selected
      -use manipulator UI?
    -if many selected
      -use generic manipulator?


::DESIGN::



::mouse states::
-active
  -in active state, an action is staged and continuously do/undo a it's being updated
  -once leaving active state, action is moved onto stack and executed

::manipulator::

::elements + layers::
-empty elt (like unity)
  -empty elt approach disadvantage is folders do not care about position and have no manipulators etc

::main events::
eltList :: Dynamic Elt -- top level elements

::elt events::
-listening
  destroyed :: Event () <- is this even needed?

::trigger events::
save :: () -> IO ()
load :: Text -> IO ()
