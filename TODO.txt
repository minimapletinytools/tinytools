
::MAJOR QUESTIONS::
NO-need some sort of zipper or map into nodes
  -how to do zipper over dynamic lists?
-another option is to give each node a UUID upon creation, and then store a map to existing nodes
  -this would be simpler
-maybe there is a simpler way just to hold refs to the RElts

-manipulators
  -

-actions
  -each manipulator is connected to elt params and has events to update it
    -e.g. boxEvent :: SBoxManipulator -> (Event t LPoint, Event t LSize)
  -front-end connects to behavior and events
    -e.g. elt behaviors => front-end =interaction=> manipulator events => elt behaviors
  -SBoxManipulator will create events of the following type:
    Event t (Action )
  -undo/redo :: Event t () -> Dynamic (Stack Action) -> Event Action

-restructuring elt tree
  -start with
    `deleteSelectedEvent :: Event t ()`
    `moveEvent :: Event t EltRef`
    `addEvent :: Event t (EltRef, ??)` -- need to figure out how to create new elts
  -pass through
    `selection :: Dynamic [EltRef]`



  -on constructing children of elt x
    -children hooks into delete/move events
    -each node also has its own delete self event which is called for GC purposes


-updating elts

-elt
  -add child event
  -remove child event


::UI STUFF::
-selection
  -select event
      -select in screen
      -select in layers
  -screen
    -if only 1 elt selected
      -use manipulator UI?
    -if many selected
      -use generic manipulator?


::DESIGN::



::mouse states::
-active
  -in active state, an action is staged and continuously do/undo a it's being updated
  -once leaving active state, action is moved onto stack and executed

::manipulator::

::elements + layers::
-empty elt (like unity)
  -empty elt approach disadvantage is folders do not care about position and have no manipulators etc

::main events::
eltList :: Dynamic Elt -- top level elements

::elt events::
-listening
  destroyed :: Event () <- is this even needed?

::trigger events::
save :: () -> IO ()
load :: Text -> IO ()
