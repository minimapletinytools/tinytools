::NEW QUESTIONS::
-do I use repeatEvent trick to move multiple elements or support interface that does it directly?
  -probably do it with repeatEvent first and switch later for performance or if you can't figure out repeatEvent nonsense

-all actions to change RElts go through manipulator

-REltDirectory needs to prune old RElts to trigger GC on them
  -removed RElts might get added back in and we want them to have the same ID
    -we could either require remove operation to carry RElt reference
    -or we could add prune operation to actions that get removed from action stack

---------
I did a little research myself and found no pure reactive data structure libraries out there. The closest thing I found was: https://hackage.haskell.org/package/reflex-dom-retractable which is a reactive stack. However events are routed through performEvent in the IO monad.

I simplified the problem at hand a little for myself and decided a dynamic list should be sufficient.

I went ahead and implemented + tested this:

For zippers, static indices are sufficient. They are partial and very execution order dependent (i.e. because indices change after each update)

I think one could make dynamic indices into the list if you need execution order independence.

Or, I can add (Eq a) constraint to uniquely identify elements in the list to solve this problem.
I found this library which sorta solves this problem http://hackage.haskell.org/package/reflex-transformers-0.2.1/docs/Reflex-Monad-Supply.html

------
::MAJOR QUESTIONS::
-elt tree
  NO-need some sort of zipper or map into nodes
    -how to do zipper over dynamic lists?
      -doable, but each zipper is O(n)
    -another way to have static zippers that get destroyed each time the tree changes
      -[REltTree t] list of parents leading up to the node
      -prob still need UUID in each node to do comparison
      -not so great for our selection system
  -another option is to give each node a UUID upon creation, and then store a map to existing nodes
    -this would be simpler
  -maybe there is a simpler way just to hold refs to the RElts
-groupable elt list then?
  -groups can be defined by start and end elt

-manipulators
  -

-actions
  -each manipulator is connected to elt params and has events to update it
    -e.g. boxEvent :: SBoxManipulator -> (Event t LPoint, Event t LSize)
  -front-end connects to behavior and events
    -e.g. elt behaviors => front-end =interaction=> manipulator events => elt behaviors
  -SBoxManipulator will create events of the following type:
    Event t (Action )
  -undo/redo :: Event t () -> Dynamic (Stack Action) -> Event Action

-restructuring elt tree
  -start with
    `deleteSelectedEvent :: Event t ()`
    `moveEvent :: Event t EltRef`
    `addEvent :: Event t (EltRef, ??)` -- need to figure out how to create new elts
  -pass through
    `selection :: Dynamic [EltRef]`
  -on constructing children of elt x
    -children hooks into delete/move events
    -each node also has its own delete self event which is called for GC purposes


-updating elts

-elt
  -add child event
  -remove child event


::UI STUFF::
-selection
  -select event
      -select in screen
      -select in layers
  -screen
    -if only 1 elt selected
      -use manipulator UI?
    -if many selected
      -use generic manipulator?


::DESIGN::



::mouse states::
-active
  -in active state, an action is staged and continuously do/undo a it's being updated
  -once leaving active state, action is moved onto stack and executed

::manipulator::

::elements + layers::
-empty elt (like unity)
  -empty elt approach disadvantage is folders do not care about position and have no manipulators etc

::main events::
eltList :: Dynamic Elt -- top level elements

::elt events::
-listening
  destroyed :: Event () <- is this even needed?

::trigger events::
save :: () -> IO ()
load :: Text -> IO ()
