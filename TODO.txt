stack build --ghc-options="-ddump-splices"

::TODO::
-make naming in selts consistent with rest of code
-figure out deriveArgDict thing, we need show instances for debugging!!
-finish relt deserializers
-hook up manipulators? (or did I do this already)
-start reflex project
-move directory into layer
  -or just delete it for now, prob ok?

-mid priority
  -helpers to create fine grained manipulators

-low priority
  -update new testing framework to match Test.Run in reflex
  -update test cases to use new testing framework
  -relt serializers
  -refine drawers
  -see if microlens gets inlined and decide to use it if so
  -add deriveGCompare1/GEq1 to Data.GADT.Compare.TH

DONE-decide what to do with directory and REltIds
  DONE-are REltIds even needed? We can just pass in the full RElt reference
      -YES they are needed to fan events efficiently
  DONE-how to reverse map RElts to their layer positions
    DONE-or we can require front end to always pass in layer positions
      -YES as if layer position was time sensitive relt id (except it's serializes and changes)
    -this is where the seq implementation was not such a great idea
  DONE-connect remove event
DONE-connect do events to action stack in entry
DONE-remove import qualified Data.Sequence         as Seq
DONE-actually you do need a separate MControl type
IGNORE-get rid of REltFactory
DONE-high priority
  DONE-write Reflex.Data.Seq
  DONE-layertree
    -implement
    IGNORE-decide move semantics (indexing is before or after)
  DONE-create simple test app!!

DONE-id assigner
  -ids need to be obtained first before relt is created as relt needs to know its id to select its events
DONE-clean up DirectoryIdAssigner interface and tests
DONE-action input distributor
DONE-action output collector
DONE-connect layer tree in entry
DONE-fan out/in actions for actionstack in entry
DONE-manipulators
  DONE-design


-feature creep 0
  -save/load workspace
    -clear workspace
  -multi select
    -multi delete
    -multi manipulate
  -move
-feature creep 1
  -PFCReorder :: PFCmdTag t (REltId, LayerPos)
-feature creep 2
  -copy pasta
  -PFCPaste :: PFCmdTag t ([SElt t], LayerPos)
  -PFCDuplicate :: PFCmdTag t [REltId]
  -deleting/moving layer elts that are not in order
-feature creep 3
  -connected elts
  -RElt manipulators now require readonly hooks into existing RElts
    -connected :: Dynamic t REltId
    -reltUpdateds :: Dynamic t (DMap (Const2 REltId REltLabel) Identity)
    -connectedUpdates' :: fmap (\i -> select i . fan reltUpdates) connected :: Event t [Event t REltLabel]
    -connectedUpdateds :: sequence . switch $ ConnectedUpdates' :: Event t [REltLabel t]
    -now you can set manipulators based on new relt positions
      -be sure the set operations are reversible
        -this way if we undo an action on a connected element state is still as expected
        -don't forget about delete events!

::NEW QUESTIONS::
-do I use repeatEvent trick to move multiple elements or support interface that does it directly?
  -probably do it with repeatEvent first and switch later for performance or if you can't figure out repeatEvent nonsense

-all actions to change RElts go through manipulator

-REltFactory needs to pass on layer pos information for where the SEltTree is going to be inserted D:

DONE-REltDirectory needs to prune old RElts to trigger GC on them
  -removed RElts might get added back in and we want them to have the same ID
    THIS-we could either require remove operation to carry RElt reference
    -or we could add prune operation to actions that get removed from action stack

---------
I did a little research myself and found no pure reactive data structure libraries out there. The closest thing I found was: https://hackage.haskell.org/package/reflex-dom-retractable which is a reactive stack. However events are routed through performEvent in the IO monad.

I simplified the problem at hand a little for myself and decided a dynamic list should be sufficient.

I went ahead and implemented + tested this:

For zippers, static indices are sufficient. They are partial and very execution order dependent (i.e. because indices change after each update)

I think one could make dynamic indices into the list if you need execution order independence.

Or, I can add (Eq a) constraint to uniquely identify elements in the list to solve this problem.
I found this library which sorta solves this problem http://hackage.haskell.org/package/reflex-transformers-0.2.1/docs/Reflex-Monad-Supply.html

------
::MAJOR QUESTIONS::
-elt tree
  NO-need some sort of zipper or map into nodes
    -how to do zipper over dynamic lists?
      -doable, but each zipper is O(n)
    -another way to have static zippers that get destroyed each time the tree changes
      -[REltTree t] list of parents leading up to the node
      -prob still need UUID in each node to do comparison
      -not so great for our selection system
  -another option is to give each node a UUID upon creation, and then store a map to existing nodes
    -this would be simpler
  -maybe there is a simpler way just to hold refs to the RElts
-groupable elt list then?
  -groups can be defined by start and end elt

-manipulators
  -

-actions
  -each manipulator is connected to elt params and has events to update it
    -e.g. boxEvent :: SBoxManipulator -> (Event t LPoint, Event t LSize)
  -front-end connects to behavior and events
    -e.g. elt behaviors => front-end =interaction=> manipulator events => elt behaviors
  -SBoxManipulator will create events of the following type:
    Event t (Action )
  -undo/redo :: Event t () -> Dynamic (Stack Action) -> Event Action

-restructuring elt tree
  -start with
    `deleteSelectedEvent :: Event t ()`
    `moveEvent :: Event t EltRef`
    `addEvent :: Event t (EltRef, ??)` -- need to figure out how to create new elts
  -pass through
    `selection :: Dynamic [EltRef]`
  -on constructing children of elt x
    -children hooks into delete/move events
    -each node also has its own delete self event which is called for GC purposes


-updating elts

-elt
  -add child event
  -remove child event


::UI STUFF::
-selection
  -select event
      -select in screen
      -select in layers
  -screen
    -if only 1 elt selected
      -use manipulator UI?
    -if many selected
      -use generic manipulator?


::DESIGN::



::mouse states::
-active
  -in active state, an action is staged and continuously do/undo a it's being updated
  -once leaving active state, action is moved onto stack and executed

::manipulator::

::elements + layers::
-empty elt (like unity)
  -empty elt approach disadvantage is folders do not care about position and have no manipulators etc

::main events::
eltList :: Dynamic Elt -- top level elements

::elt events::
-listening
  destroyed :: Event () <- is this even needed?

::trigger events::
save :: () -> IO ()
load :: Text -> IO ()
