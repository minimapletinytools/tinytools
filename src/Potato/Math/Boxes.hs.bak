-- just a sketch for new math library

{-# LANGUAGE RecordWildCards      #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}


module Potato.Math.Boxes (
) where


import           Relude

import           Control.Exception (assert)
import           Data.Aeson
import           Linear.V2
import qualified Text.Show

{-
 CORDINATE SYSTEM
 UPPER LEFT CORNER is 0 0
 (0,0)--- +x
  |
  |
  +y
-}

data Point = Point Int Int
data Size = Size Int Int

instance Num Point => Num Point where
  Point x1 y1 + Point x2 y2 = Point (x1+y1) (x2+y2)
  {-# INLINE (+) #-}
  Point x1 y1 - Point x2 y2 = Point (x1-y1) (x2-y2)
  {-# INLINE (-) #-}
  Point x1 y1 * Point x2 y2 = Point (x1*y1) (x2*y2)
  {-# INLINE (*) #-}
  negate (Point x y) = Point (-x) (-y)
  {-# INLINE negate #-}
  abs (Point x y) = Point (abs x) (abs y)
  {-# INLINE abs #-}
  signum (Point x y) = Point (abs x) (abs y)
  {-# INLINE signum #-}
  fromInteger i = Point i i
  {-# INLINE fromInteger #-}

data Box = Box {
  ul     :: Point
  , size :: Size
} deriving (Show, Eq, Generic)

instance FromJSON LBox
instance ToJSON LBox
instance NFData LBox


make_LBox_from_ul_br :: LPoint -> LPoint -> LBox
make_LBox_from_ul_br (LPoint (V2 x1 y1)) (LPoint (V2 x2 y2)) =
  LBox {
    ul = LPoint $ V2 (min x1 x2) (min y1 y2)
    , size = LSize $ V2 (abs (x1 - x2)) (abs (y1 - y2))
  }

does_LBox_contains_XY :: Box -> Point -> Bool
does_LBox_contains_XY (LBox (LPoint (V2 bx by)) (LSize (V2 bw bh))) (LPoint (V2 px py)) =
  px >= bx && py >= by && px < (bx + bw) && py < (by + bh)

-- TODO
--union_Box :: Box -> Box -> Box
--union_Box b1 = const lb1
